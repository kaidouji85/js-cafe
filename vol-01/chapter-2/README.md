# 2-1　JavaScriptの基本的な記法

## コメントやnoscriptは必要？

ほぼ必要は無い。

- ガラケーの一部がjs未対応みたい。

## scriptコードはどこに書く？

1. scriptタグ内に埋め込み
1. 外部ファイル呼び出し

基本、外部ファイル。

## scriptタグの位置

1. 一般的：headタグ配下
1. 重い処理を描写最後に埋め込みたい：/body終了タグの直前
1. ajax処理結果等やむを得ない場合：bodyタグ内

## ルール

- 末尾にセミコロンつける

## コメント

注意：Browserから丸見えなので、あまり開発ちっくなコメントを書かない。

# 2-2　変数

## 宣言

`var 変数 = 初期値 ;`

※無くても動く。但し、global変数になってしまう（無駄にメモリに居続ける）ので避けるべき。

## 識別子

- 頭に数値はNG
- 記号は避けよう
- 予約語は避けよう

変数名、メソッド名等のネーミングは第3者に分かり易い名前に。

## 記法

- camelCase：変数名、関数名
- Pascal：クラス（コンストラクタ）
- アンダースコア：玉に変数名(camelならcamelで揃えるべき)

# 2-3　データ型

- 基本型
 - number：数値(MAX=???)
 - string：文字列
 - boolean：真偽
 - null / undefined：未定義
- 参照型
 - array：データの集合（インデックス番号でアクセス）
 - object：データの集合（名前でアクセス）
 - function：処理手続きの集合

## 特徴

`数値の型が1つ`

- number
 - 整数リテラル
  - 10進数
  - 8進数
  - 16進数
 - 浮動小数点リテラル

`nullとundefined`

`hashの代わりにobject`

`functionが独立している`

`途中で型を変えて良い？`

## リテラル

値の表現方法

- 数値リテラル
- 文字列リテラル
 - クオートで囲まれた文字列

## クオート

シングルクオート、ダブルクオートいずれも可。

文字列の中で、クオート入れたい場合に、意識して違うクオートで文字列を囲う。

`"例えば'こんな風に'書いたり"`
`'あるいは"こんな風に"書いたり'`

（後述のエスケープシーケンスあれば、同じクオートも使える）

## エスケープシーケンス

よく使うヤツ
- ¥n：改行
- ¥r：復帰
- ¥t：タブ
- ¥'：シングルクォート
- ¥"：ダブルクォート

## 改行について

¥r¥n：改行されない

brタグを使う

## 配列

データの集合

- インデックス番号は0から始まる


### 書き方

- データ格納

`変数 = [内容1, 内容2]`

- データ追加

`変数.push(内容3)`

- データ読み込み

`配列名[インデックス番号]`


### 例

- 1

`x = [123, "abc", 3.14]`

`x[1] //"abc"`

- 2

`> y = [ [ "181cm", "59kg"], ["179cm", "65kg"]]`

`> y[1][0]  //179cm`

## object

連想配列。名前をキーにアクセスできるデータの集合。

### 書き方

- データ格納

`変数 = {キー名:値, キー名:値}`

- データ読み込み
 - ブラケット記法
  `変数[キー名]`
 - ドット演算子
  `変数.キー名`

- データ追加

`変数[キー名] = 値`

### 例

`tanaka = {"height":179, "weight":65}`

`tanaka["height"] //179`

`tanaka.weight //65`

`tanaka['age'] = 29`

## function

関数（処理の固まり）

### 例

`var 変数 = function(引数1, 引数2, ・・・) {関数の本体}`



## undefined

- 宣言済みだが値が入ってない変数

 `var x;`

 `document.writeln(x); //undefined`

- 未定義のプロパティを参照

 `var obj = {a:123};`

 `document.writeln(obj.b); //undefined`


# 2-4　演算子

- オペレータ
 - 算術演算子：+-等
 - 代入演算子：=等
 - 比較演算子：>等
 - 論理演算子： &&等
 - ビット演算子：&等
 - その他
- オペランド
 - リテラル
 - 変数

## 算術演算子：+-等

特殊なもののみ

- %：割り算のあまり
- ++：前(後)置加算
- --：前(後)置減算

### +のオペランドの型による動作の違い

- 数値同士：数の加算
- 文字列同士：文字の連結
- オブジェクト同士：オブジェクトを文字列形式に変換して連結。

### increment(++)/decrement(--)

`x++ => x = x + 1;`

- 前置演算

> var x = 1
>
> var y = x++; //1

1. yにx(=1)を代入
1. xに1を追加

- 後置演算

> var x = 1
>
> var y = ++x; //2

1. xに1を追加
1. yにx(=2)を代入

### 小数点

> 0.2 * 3
>
> = 0.6000000000000001

## 代入演算子：=等

### 複合代入演算子

`x += y`

`x = x + y`

### 基本型と参照型の代入の違い

- 基本型
 - 値渡し(シャローコピー)：値をそのまま格納
- 参照型
 - 参照渡し(ディープコピー)：メモリのアドレスを格納

## 比較演算子

- not equal
 - !=
 - hit markがnot

### ==(等価演算子)

- 基本型：データの型が違っても、"なんとなく"等しければTRUE

> 1 == true //true
> 
> 1 == "1" //true 
> 
> null == undefined //true
>

- 参照型：同じ値で、アドレスも全く同じでTRUE


> ["a","b","c"] == ["a","b","c"] // false
> 
> a = ["a","b","c"]
>
> b = a
> 
> a == b //true

### === 同値演算子

- データの型も値も同じであればTRUE

> "3.14E2" == 314 //true
>
> "3.14E2" == 314 //false
>
> '0x10' == 16 //true
> 
> '0x10' === 16 //false

- あまり使う事は無いような気がする。
 - 何かライブラリ系のソースリーディングしている際に出てくる程度？

### ==(等価演算子)と===(同値演算子)の違い

- == 等価演算子：データ型気にせず判定
- === 同値演算子：データ型気にして判定

### ３項演算子 / 条件演算子( ? : )

`条件式 ? trueの場合の式 : falseの場合の式`

> var x = 80;
>
> document.writeln((x >= 70) ? 'OK' : 'NG')

## 論理演算子

### false

- 空文字("")
- 0
- NaN
- null
- undefined

### 論理演算子の短絡的評価

- x && y
- 左辺 論理演算子 右辺

`左辺の状態で結果が明らかである場合、右辺まで評価しない`

- true || false
 - 左辺のtrueだけで、右辺がtrueでもfalseでも、結果はtrue
  - なので、わざわざ右辺を評価しない
  - false && true
   - 左辺のfalseだけで、右辺がtrueでもfalseでも、結果はfalse
    - なので、わざわざ右辺を評価しない



# 2-5　制御命令



